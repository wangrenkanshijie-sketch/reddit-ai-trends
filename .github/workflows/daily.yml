name: Daily Reddit AI Trends

on:
  schedule:
    - cron: "5 6 * * *"   # 每天 06:05 UTC 运行
  workflow_dispatch:

jobs:
  build:
    runs-on: ubuntu-latest

    permissions:
      contents: write    # 允许回推 reports 目录

    steps:
      - name: Checkout repo
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Install deps
        run: pip install -r requirements.txt

      - name: Generate reports (EN+ZH)
        env:
          REDDIT_CLIENT_ID: ${{ secrets.REDDIT_CLIENT_ID }}
          REDDIT_CLIENT_SECRET: ${{ secrets.REDDIT_CLIENT_SECRET }}
          REDDIT_USER_AGENT: ${{ secrets.REDDIT_USER_AGENT }}
          GROQ_API_KEY: ${{ secrets.GROQ_API_KEY }}
          REPORT_LANGUAGES: ${{ secrets.REPORT_LANGUAGES }}
        run: python report_generation.py --languages en zh

      - name: Commit & push reports
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
          git add reports/
          git commit -m "Daily report update" || echo "No changes to commit"
          git push

      # ===================== 推送到 Notion（原生块渲染） =====================
      - name: Push reports to Notion (ZH & EN)
        env:
          NOTION_API_KEY: ${{ secrets.NOTION_API_KEY }}
          NOTION_DATABASE_ID: ${{ secrets.NOTION_DATABASE_ID }}
        run: |
          python - <<'PY'
          import os, json, datetime, pathlib, re, requests
          from html import unescape

          TOKEN = os.environ["NOTION_API_KEY"]
          DB_ID = os.environ["NOTION_DATABASE_ID"]
          TITLE_PROP = "Title"     # 你的数据库列名（严格大小写）
          DATE_PROP  = "Date"
          CONTENT_PROP = "Content"

          HEADERS = {
              "Authorization": f"Bearer {TOKEN}",
              "Notion-Version": "2022-06-28",
              "Content-Type": "application/json",
          }

          def chunk_text(text, size=1800):
              for i in range(0, len(text), size):
                  yield text[i:i+size]

          def rich(text):
              return [{"type":"text","text":{"content": text}}]

          def link_rich(title, url):
              return [{"type":"text","text":{"content": title,"link":{"url":url}}}]

          # --- 把 markdown 表格解析成 bulleted list（标题+元信息） ---
          def parse_table(lines, start):
              if start+1>=len(lines): return None, start
              header = lines[start]
              sep    = lines[start+1]
              if "|" not in header or not re.search(r"^\s*\|?\s*-", sep):
                  return None, start
              items = []
              i = start+2
              while i < len(lines) and "|" in lines[i]:
                  row = [c.strip() for c in lines[i].strip().strip("|").split("|")]
                  items.append(row)
                  i += 1
              return items, i-1

          def cell_link_or_text(cell):
              m = re.search(r"\[([^\]]+)\]\(([^)]+)\)", cell)
              if m:
                  return ("link", m.group(1).strip(), m.group(2).strip())
              return ("text", re.sub(r"\s+", " ", cell).strip())

          def md_to_blocks(md: str):
              lines = md.splitlines()
              blocks = []
              buf_para = []

              def flush_para():
                  if not buf_para: return
                  text = "\n".join(buf_para).strip()
                  if text:
                      for seg in chunk_text(text):
                          blocks.append({"type":"paragraph","paragraph":{"rich_text":rich(seg)}})
                  buf_para.clear()

              i = 0
              in_code = False
              code_lang = ""
              code_buf = []

              while i < len(lines):
                  ln = lines[i]

                  # fenced code
                  mcode = re.match(r"^```(\w+)?\s*$", ln)
                  if mcode:
                      if not in_code:
                          flush_para()
                          in_code = True
                          code_lang = (mcode.group(1) or "").lower()
                          code_buf = []
                      else:
                          code_text = "\n".join(code_buf)
                          blocks.append({"type":"code","code":{
                              "language": code_lang or "plain text",
                              "rich_text": [{"type":"text","text":{"content": code_text}}]
                          }})
                          in_code = False
                          code_lang = ""
                          code_buf = []
                      i += 1
                      continue
                  if in_code:
                      code_buf.append(ln)
                      i += 1
                      continue

                  # headings
                  mh = re.match(r"^(#{1,3})\s+(.*)$", ln)
                  if mh:
                      flush_para()
                      level = min(len(mh.group(1)),3)
                      title = mh.group(2).strip()
                      blocks.append({
                          "type": f"heading_{level}",
                          f"heading_{level}": {"rich_text": rich(title)}
                      })
                      i += 1
                      continue

                  # hr
                  if re.match(r"^\s*---+\s*$", ln):
                      flush_para()
                      blocks.append({"type":"divider","divider":{}})
                      i += 1
                      continue

                  # tables -> list
                  table_items, end_idx = parse_table(lines, i)
                  if table_items:
                      flush_para()
                      header = table_items[0] if table_items else []
                      for row in table_items[1:]:
                          cells = row + [""]*(max(0, len(header)-len(row)))
                          first = cells[0] if cells else ""
                          kind, a, b = cell_link_or_text(first)
                          if kind == "link":
                              rt = link_rich(a, b)
                          else:
                              rt = rich(a)

                          metas = []
                          if len(cells) > 1: metas.append(cells[1])                   # Community
                          if len(cells) > 2: metas.append(f"Score {cells[2]}")       # Score
                          if len(cells) > 3: metas.append(f"Comments {cells[3]}")    # Comments
                          if len(cells) > 4: metas.append(cells[4])                  # Category
                          if len(cells) > 5: metas.append(cells[5])                  # Posted
                          meta = " · ".join([m for m in metas if m])
                          if meta:
                              rt = rt + [{"type":"text","text":{"content": f" — {meta}"}}]

                          blocks.append({
                              "type":"bulleted_list_item",
                              "bulleted_list_item":{"rich_text": rt}
                          })
                      i = end_idx + 1
                      continue

                  # blank line => end paragraph
                  if ln.strip()=="":
                      flush_para()
                  else:
                      buf_para.append(ln)
                  i += 1

              flush_para()
              return blocks

          def create_page(title: str, md: str):
              blocks = md_to_blocks(unescape(md))
              today = datetime.date.today().isoformat()
              summary = (md.replace("\n"," ")[:1800] or "见页面正文")
              props = {
                  TITLE_PROP:   {"title":     [{"type":"text","text":{"content": title}}]},
                  DATE_PROP:    {"date":      {"start": today}},
                  CONTENT_PROP: {"rich_text": [{"type":"text","text":{"content": summary}}]},
              }
              payload = {"parent":{"database_id": DB_ID}, "properties": props, "children": blocks[:200]}
              r = requests.post("https://api.notion.com/v1/pages", headers=HEADERS, data=json.dumps(payload))
              if r.status_code >= 300:
                  raise SystemExit(f"Create page failed: {r.status_code} {r.text}")
              page_id = r.json()["id"]
              for i in range(200, len(blocks), 200):
                  chunk = {"children": blocks[i:i+200]}
                  rr = requests.patch(f"https://api.notion.com/v1/blocks/{page_id}/children",
                                      headers=HEADERS, data=json.dumps(chunk))
                  if rr.status_code >= 300:
                      raise SystemExit(f"Append failed: {rr.status_code} {rr.text}")
              print("Notion sync done:", title)

          # 读取并推送
          p_zh = pathlib.Path("reports/latest_report_zh.md")
          if p_zh.exists():
              md_zh = p_zh.read_text(encoding="utf-8").strip()
              create_page(f"AI 趋势日报（ZH）{datetime.date.today().isoformat()}", md_zh)
          else:
              print("WARN: latest_report_zh.md not found, skip ZH")

          p_en = pathlib.Path("reports/latest_report_en.md")
          if p_en.exists():
              md_en = p_en.read_text(encoding="utf-8").strip()
              create_page(f"AI Trends Daily (EN) {datetime.date.today().isoformat()}", md_en)
          else:
              print("WARN: latest_report_en.md not found, skip EN")
          PY
