  name: Daily Reddit AI Trends

on:
  schedule:
    - cron: "5 6 * * *"   # 每天 06:05 UTC 自动运行
  workflow_dispatch:       # 允许手动触发

jobs:
  build:
    runs-on: ubuntu-latest

    permissions:
      contents: write   # 允许回推 reports 目录

    steps:
      - name: Checkout repo
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Install deps
        run: pip install -r requirements.txt

      # 生成中/英报告（保持你仓库里的脚本调用方式）
      - name: Generate reports (EN+ZH)
        env:
          REDDIT_CLIENT_ID: ${{ secrets.REDDIT_CLIENT_ID }}
          REDDIT_CLIENT_SECRET: ${{ secrets.REDDIT_CLIENT_SECRET }}
          REDDIT_USER_AGENT: ${{ secrets.REDDIT_USER_AGENT }}
          GROQ_API_KEY: ${{ secrets.GROQ_API_KEY }}
          REPORT_LANGUAGES: ${{ secrets.REPORT_LANGUAGES }}
        run: python report_generation.py --languages en zh

      # 提交最新报告到仓库
      - name: Commit & push reports
        run: |
          git config --global user.name "github-actions[bot]"
          git config --global user.email "41898282+github-actions[bot]@users.noreply.github.com"
          git add reports/
          git commit -m "Daily report update" || echo "No changes to commit"
          git push

      # 把 Markdown 推送到 Notion 数据库（自动创建两条记录：ZH/EN）
      - name: Push reports to Notion (ZH & EN)
        env:
          NOTION_API_KEY: ${{ secrets.NOTION_API_KEY }}
          NOTION_DATABASE_ID: ${{ secrets.NOTION_DATABASE_ID }}
        run: |
          python - <<'PY'
          import os, re, json, datetime, pathlib, requests

          TOKEN = os.environ["NOTION_API_KEY"]
          DB_ID = os.environ["NOTION_DATABASE_ID"]

          # === Notion API 基本头 ===
          HEADERS = {
              "Authorization": f"Bearer {TOKEN}",
              "Notion-Version": "2022-06-28",
              "Content-Type": "application/json",
          }

          # === 将 Markdown 转成 Notion blocks（简洁稳妥：标题/段落）===
          # 1) 行首 #### / ### / ## / # 识别为 heading
          # 2) 其它行作为 paragraph；表格行(|)先转为普通文本
          # 3) 每段做 1800 字分块，避免 rich_text 过长
          def md_to_blocks(markdown: str):
              def para_block(text: str):
                  return {
                      "object": "block",
                      "type": "paragraph",
                      "paragraph": { "rich_text": [ { "type": "text", "text": { "content": text } } ] }
                  }

              def heading_block(level: int, text: str):
                  key = {1:"heading_1", 2:"heading_2", 3:"heading_3"}.get(level, "heading_3")
                  return {
                      "object": "block",
                      "type": key,
                      key: { "rich_text": [ { "type": "text", "text": { "content": text } } ] }
                  }

              # 去掉 Markdown 表格竖线，避免生成巨长的富文本段落
              markdown = re.sub(r"\|", " ", markdown)

              blocks = []
              for raw in markdown.splitlines():
                  line = raw.rstrip()

                  # 标题
                  m = re.match(r'^(#{1,6})\s+(.*)$', line)
                  if m:
                      hashes, text = m.group(1), m.group(2).strip()
                      level = min(len(hashes), 3)  # 限为 1~3
                      if text:
                          blocks.append(heading_block(level, text))
                      continue

                  # 空行 → 转成空段落（让版面更舒展）
                  if not line:
                      blocks.append(para_block(""))
                      continue

                  # 普通段落，1800 字分块
                  CHUNK = 1800
                  for i in range(0, len(line), CHUNK):
                      blocks.append(para_block(line[i:i+CHUNK]))

              return blocks

          # === 创建 Notion 页面 ===
          def create_page(title: str, date_val: datetime.date):
              props = {
                  "Name": { "title": [ { "type": "text", "text": { "content": title } } ] },
                  "Date": { "date": { "start": date_val.isoformat() } }
              }
              payload = {
                  "parent": { "database_id": DB_ID },
                  "properties": props
              }
              r = requests.post("https://api.notion.com/v1/pages", headers=HEADERS, json=payload)
              if r.status_code >= 300:
                  raise RuntimeError(f"Create page failed: {r.status_code} {r.text}")
              return r.json()["id"]

          # === 追加 children，分批 <= 90，规避 Notion 100 blocks 限制 ===
          def append_children(page_id: str, children: list, batch_size: int = 90):
              for i in range(0, len(children), batch_size):
                  chunk = children[i:i+batch_size]
                  url = f"https://api.notion.com/v1/blocks/{page_id}/children"
                  r = requests.patch(url, headers=HEADERS, json={"children": chunk})
                  if r.status_code >= 300:
                      raise RuntimeError(f"Append failed: {r.status_code} {r.text}")

          # === 读取并推送单份报告 ===
          def push_one(lang_tag: str, md_path: str):
              p = pathlib.Path(md_path)
              if not p.exists():
                  print(f"[WARN] {md_path} not found, skip {lang_tag}")
                  return

              text = p.read_text(encoding="utf-8")
              blocks = md_to_blocks(text)

              today = datetime.date.today()
              if lang_tag.upper() == "ZH":
                  title = f"AI 趋势日报（ZH）{today.isoformat()}"
              else:
                  title = f"AI Trends Daily (EN) {today.isoformat()}"

              page_id = create_page(title, today)
              append_children(page_id, blocks, batch_size=90)
              print(f"[OK] Notion synced: {title}")

          # === 执行：先中文，再英文 ===
          push_one("ZH", "reports/latest_report_zh.md")
          push_one("EN", "reports/latest_report_en.md")
          PY
