  name: Daily Reddit AI Trends

on:
  schedule:
    - cron: "5 6 * * *"   # 每天 06:05 UTC 自动运行
  workflow_dispatch:       # 允许手动触发

jobs:
  build:
    runs-on: ubuntu-latest

    permissions:
      contents: write   # 允许回推 reports 目录

    steps:
      - name: Checkout repo
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Install deps
        run: pip install -r requirements.txt

      - name: Generate reports (EN+ZH)
        env:
          REDDIT_CLIENT_ID: ${{ secrets.REDDIT_CLIENT_ID }}
          REDDIT_CLIENT_SECRET: ${{ secrets.REDDIT_CLIENT_SECRET }}
          REDDIT_USER_AGENT: ${{ secrets.REDDIT_USER_AGENT }}
          GROQ_API_KEY: ${{ secrets.GROQ_API_KEY }}
          REPORT_LANGUAGES: ${{ secrets.REPORT_LANGUAGES }}
        run: python report_generation.py --languages en zh

      - name: Commit & push reports
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
          git add reports/
          git commit -m "Daily report update" || echo "No changes to commit"
          git push

      - name: Push reports to Notion (ZH & EN)
        env:
          NOTION_API_KEY: ${{ secrets.NOTION_API_KEY }}
          NOTION_DATABASE_ID: ${{ secrets.NOTION_DATABASE_ID }}
        run: |
          python - <<'PY'
          import os, re, json, datetime, pathlib, requests

          TOKEN = os.environ["NOTION_API_KEY"]
          DB_ID = os.environ["NOTION_DATABASE_ID"]

          # 你的数据库属性名：Title（title）和 Date（date）
          TITLE_PROP = "Title"
          DATE_PROP = "Date"

          HEADERS = {
              "Authorization": f"Bearer {TOKEN}",
              "Notion-Version": "2022-06-28",
              "Content-Type": "application/json",
          }

          # —— 简单 Markdown -> Notion blocks（段落/标题） ——
          def md_to_blocks(markdown: str):
              # 去掉 Markdown 表格竖线，避免太长的 rich_text
              markdown = re.sub(r"\|", " ", markdown)

              blocks = []
              for ln in markdown.splitlines():
                  if not ln.strip():
                      # 空行插入段落空行
                      blocks.append({
                          "object": "block",
                          "type": "paragraph",
                          "paragraph": {"rich_text": []}
                      })
                      continue

                  # 识别标题（#/##/###）
                  m = re.match(r'^(#{1,3})\s+(.*)$', ln)
                  if m:
                      level = len(m.group(1))
                      text = m.group(2)[:1800]
                      blocks.append({
                          "object": "block",
                          "type": "heading_" + str(level),
                          "heading_" + str(level): {
                              "rich_text": [{"type": "text", "text": {"content": text}}]
                          }
                      })
                  else:
                      text = ln[:1800]
                      blocks.append({
                          "object": "block",
                          "type": "paragraph",
                          "paragraph": {
                              "rich_text": [{"type": "text", "text": {"content": text}}]
                          }
                      })
              return blocks

          def create_page(title: str, date_val: datetime.date):
              payload = {
                  "parent": {"database_id": DB_ID},
                  "properties": {
                      TITLE_PROP: {"title": [{"type": "text", "text": {"content": title}}]},
                      DATE_PROP: {"date": {"start": date_val.isoformat()}}
                  }
              }
              r = requests.post("https://api.notion.com/v1/pages",
                                headers=HEADERS, json=payload)
              if r.status_code >= 300:
                  raise RuntimeError(f"Create page failed: {r.status_code} {r.text}")
              return r.json()["id"]

          def append_children(page_id: str, children: list, batch_size: int = 90):
              # Notion 限制一次 children 追加最多 100，这里保守取 90
              for i in range(0, len(children), batch_size):
                  chunk = children[i:i+batch_size]
                  url = f"https://api.notion.com/v1/blocks/{page_id}/children"
                  r = requests.patch(url, headers=HEADERS, json={"children": chunk})
                  if r.status_code >= 300:
                      raise RuntimeError(f"Append children failed: {r.status_code} {r.text}")

          # —— 读取最新生成的 MD（中文/英文），推送到 Notion ——
          today = datetime.date.today()

          def push_one(md_path: pathlib.Path, lang_tag: str):
              if not md_path.exists():
                  raise FileNotFoundError(f"{md_path} not found")

              md_text = md_path.read_text(encoding="utf-8")
              blocks = md_to_blocks(md_text)

              title = f"AI Trends Daily ({lang_tag}) {today.isoformat()}"
              page_id = create_page(title, today)
              append_children(page_id, blocks)

              print(f"Notion sync done: {title}")

          p_zh = pathlib.Path("reports/latest_report_zh.md")
          p_en = pathlib.Path("reports/latest_report_en.md")

          # 有哪个就发哪个，两个都发则会在 Notion 里生成两行
          if p_zh.exists():
              push_one(p_zh, "ZH")
          else:
              print("WARN: latest_report_zh.md not found, skip ZH")

          if p_en.exists():
              push_one(p_en, "EN")
          else:
              print("WARN: latest_report_en.md not found, skip EN")
          PY
